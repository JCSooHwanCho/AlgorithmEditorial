문제 번호 : 1208A  
문제명 : XORinacci  
문제 링크 : http://codeforces.com/problemset/problem/1208/A  
카테고리: math  
소요시간 : 5 분

---  

문제 풀이

피보나치 수열에서 덧셈 연산을 XOR 연산으로 바꾼 문제이다. 단순히 순서를 구하는 문제라면 동적계획법으로 문제를 풀어도 될 것이다. 다만 0값의 범위가 0<= a,b,n <=10^9이고 쿼리 수가 최대 1000개나 되므로 매 쿼리마다 캐시를 만들다가는 시간초과가 날 것 같다. 다른 방법을 사용해야한다. 근데 예제를 파악하기 위해 값을 나열하다보니 규칙성이 보이는 것 같다. 값들이 반복된다! 왜 반복되는 것일까?

XOR 연산은 다음과 같은 성질을 가진다.

1. a^a == 0, a^0 == a(항등법칙, 0은 XOR의 항등원, 임의의 수 a의 역원은 a 자신)
2. a^b == b^a (교환법칙)

처음 주어진 수를 a,b라고 할 때 수열을 나열해보면

> a, b, a^b , a^b^b, a^b^b^a^b ...

이를 정리하면 다음과 같다.

> a, b, a^b, a(a^b^b -> a^0 -> a), b(a^b^b^a^b -> a^0^a^b -> a^a^b -> 0^b - > b)  

즉, a,b, a^b가 반복되는 수열인 것이다. 그래서 f(3n) = f(0) = a, f(3n+1) = f(1), f(3n+2) = f(2)가 성립하고, n이 얼마가 주어지던 나머지 연산 1번이면 쉽게 답을 찾을 수 있다.

입력이 아무리 크더라도 계산 횟수는 항상 일정하므로 시간 복잡도는 O(1)이다.
* 정답 코드
  
```c++
#include<iostream>
 
 
int main() {
    int t;
    
    std::cin>>t;
    long long num[3];
    long long n;
    while(t--) {
        std::cin>>num[0]>>num[1]>>n;
        
        num[2] = num[0]^num[1];
        
        std::cout<<num[n%3]<<"\n";
    }
    
    return 0;
}
```